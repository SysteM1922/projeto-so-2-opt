% Genetic algorithm

%PLAN
%{  
    % initialize the population
    % fitness evaluation
    % selection
    % crossover
    % mutation
    % elitism
    % termination and update the population
    % output
%}
function GeneticAlgorithmCND(NodesFile, LinksFile, LFile, c, runtimeLimit, populationSize, mutationRate, elitismCount)
    % Load the graph data
    Nodes = load(NodesFile);
    Links = load(LinksFile);
    L = load(LFile);
    nNodes = size(Nodes, 1);
    % Create graph
    G = graph(L);
    
    % Run the GA
    bestSolution = [];
    bestCost = Inf;
    
    % Initialize population
    population = InitializePopulation(populationSize, nNodes, c);
    
    startTime = tic;
    while toc(startTime) < runtimeLimit       
        % Initialize new population - P'
        newPopulation = zeros(populationSize, c);
        
        costs = EvaluateCosts(G, population);

        for i = 1:populationSize
            % An individual s is generated by the Crossover operator
            s = Crossover(population, costs, nNodes, c);
            
            % Mutation
            if rand < mutationRate
                s = Mutation(s, nNodes);
            end
            
            % P' = P' U s
            newPopulation(i, :) = s;
        end
        
        % Update population
        population = Selection(G, population, newPopulation, elitismCount);
    end
    
    % sbest = Best(P)
    costs = EvaluateCosts(G, population);
    [bestCost, bestIdx] = min(costs);
    bestSolution = population(bestIdx, :);
    % cost for the best solution
    bestCost = ConnectedNP(G, bestSolution);
        
    % Output the best solution
    fprintf("\nGenetic Algorithm for CND Problem\n");
    fprintf("C value: %d\n", c);
    fprintf("Best solution: %s\n", mat2str(bestSolution));
    fprintf("Best cost: %f\n", bestCost);
    
    plotTopology(Nodes, Links, bestSolution);
end

function population = InitializePopulation(populationSize, nNodes, c)
    population = zeros(populationSize, c);
    for i = 1:populationSize
        individual = randperm(nNodes, c);
        while length(unique(individual)) < c
            individual = randperm(nNodes, c);
        end
        population(i, :) = individual;
    end
end

function costs = EvaluateCosts(G, population)
    populationSize = size(population, 1);
    costs = zeros(populationSize, 1);
    for i = 1:populationSize
        costs(i) = ConnectedNP(G, population(i, :));
    end
end

function selected = Selection(G, population, newPopulation, elitismCount)
    % Selection operator:
    % Selects the |P| individuals s from set P U Pâ€™ with the best value of f(s)
    % f(s) in this case is the ConnectedNP function (s)
    % Limiting the number of elitist individuals (i.e., elements of P) to a maximum value m (elitismCount)
    
    % all_p = population U newPopulation
    fullPopulation = [population; newPopulation]; 
    % Make sure this is a set by removing duplicates
    fullPopulation = unique(fullPopulation, 'rows');

    % Evaluate the fitness of each individual
    fullCosts = EvaluateCosts(G, fullPopulation);
    
    % Sort the population based on costs
    [~, sortedIdx] = sort(fullCosts);
    
    % Select the best m individuals
    selected = fullPopulation(sortedIdx(1:elitismCount), :);
    
    % Fill the rest of the selected population
    remainingCount = size(population, 1) - elitismCount;
    for i = 1:remainingCount
        competitors = randperm(size(fullPopulation, 1), 2);
        if fullCosts(competitors(1)) < fullCosts(competitors(2))
            selected(elitismCount + i, :) = fullPopulation(competitors(1), :);
        else
            selected(elitismCount + i, :) = fullPopulation(competitors(2), :);
        end
    end
end

% Parent Selection strategies
function parents = TournamentSelection(population, costs)
    % Tournament selection for choosing two parents
    % for each parent, select two random individuals and choose the most fit among the two as the parent
    parents = zeros(2, size(population, 2));
    for i = 1:2
        competitors = randperm(size(population, 1), 2);
        if costs(competitors(1)) < costs(competitors(2))
            parents(i, :) = population(competitors(1), :);
        else
            parents(i, :) = population(competitors(2), :);
        end
    end
end

function parents = FitnessBasedSelection(population, costs)
    % Fitness-based selection for choosing two parents
    % select each parent with a probability proportional to its fitness
    [~, sortedIdx] = sort(costs);
    parents = population(sortedIdx(1:2), :);
end

function parents = RankBasedSelection(population, costs)
    % Rank-based selection for choosing two parents
    % rank all individuals by their fitness value and 
    % randomly select each parent with a probability proportional to its rank

    % Rank the combined population based on costs
    [~, sortedIdx] = sort(costs);

    % Calculate selection probabilities
    selectionProbabilities = 1:length(population);
    selectionProbabilities = selectionProbabilities / sum(selectionProbabilities);

    % Select parents based on probabilities
    parents = zeros(2, size(population, 2));
    for i = 1:2
        selectedIdx = randsample(1:length(population), 1, true, selectionProbabilities);
        parents(i, :) = population(selectedIdx, :);
    end

    % Return the selected parents
    parents = population(sortedIdx(1:2), :);
end
% end of Parent Selection strategies

% Crossover operator
function offspring = Crossover(population, costs, nNodes, c)
    % Parent Selection - Choose one of the strategies
    parents = TournamentSelection(population, costs);
    % parents = FitnessBasedSelection(population, costs);
    % parents = RankBasedSelection(population, costs);

    crossoverPoint = randi(c - 1);
    offspring = [parents(1, 1:crossoverPoint), parents(2, crossoverPoint+1:end)];
    offspring = unique(offspring, 'stable');
    
    % Ensure the offspring has exactly c unique nodes
    while length(offspring) < c
        newGene = randi(nNodes);
        if ~ismember(newGene, offspring)
            offspring = [offspring, newGene];
        end
    end
end

function mutatedOffspring = Mutation(offspring, nNodes)
    % One gene of the offspring individual is randomly mutated
    mutationPoint = randi(length(offspring));
    newGene = randi(nNodes);
    while ismember(newGene, offspring)
        newGene = randi(nNodes);
    end
    mutatedOffspring = offspring;
    mutatedOffspring(mutationPoint) = newGene;
end

% Usage example
Nodes_file = 'Nodes200.txt';
Links_file = 'Links200.txt';
L_file = 'L200.txt';

c_values = [8, 10, 12];
runtime_limit = 60; % seconds

% Parameters for GA
populationSize = 100;
mutationRate = 0.2;
elitismCount = 5;

% Run the GA for different values of c
for i = 1:length(c_values)
    GeneticAlgorithmCND(Nodes_file, Links_file, L_file, c_values(i), runtime_limit, populationSize, mutationRate, elitismCount);
end
